def main():
    # parsear args: batch_size, threshold, percentil_radio…
    # entrenar autoencoder y recolectar valid_latents…
    # calcular centroid, distancias, radio_motor…
    # ahora inferencia:

    err_max = 1.0
    # Definimos err_filtro_externo a partir de threshold
    err_filtro_externo = args.threshold * 1.2

    print('[INFO] Iniciando predicción con filtro combinado de latente + reconstrucción')
    print(f'       radio_motor = {radio_motor:.5f}, err_filtro_externo = {err_filtro_externo:.5f}\n')

    while True:
        # 1) Grabar y preprocesar
        s = record_audio()
        feat = preprocess_signal(s).flatten()[np.newaxis, ...]  # (1, input_dim)

        # 2) Calcular latente y distancia
        z = encoder.predict(feat, verbose=0)[0]
        dist = np.linalg.norm(z - centroid)

        # 3a) Caso “latente dentro del radio” → motor (sano o con fallo leve)
        if dist <= radio_motor:
            rec = autoencoder.predict(feat, verbose=0)
            err = float(np.mean((feat - rec) ** 2))
            if err > err_max:
                err_max = err
                print(f'[CALIB] Nuevo err_max = {err_max:.5f}')
            if err <= args.threshold:
                pct = 0.0
            else:
                denom = max(err_max - args.threshold, 1e-6)
                pct = np.clip((err - args.threshold) / denom, 0, 1) * 100
            print(f'[MOTOR] dist={dist:.5f} ≤ {radio_motor:.5f}, Error={err:.5f}, Daño={pct:6.2f}%\n')
            continue

        # 3b) Caso “latente fuera del radio”: potencial ruido externo o motor muy roto
        rec = autoencoder.predict(feat, verbose=0)
        err = float(np.mean((feat - rec) ** 2))

        # 3b.1) Si err está por debajo de err_filtro_externo → RUÍDO EXTERNO → descartar
        if err <= err_filtro_externo:
            print(f'[FILTRO] dist={dist:.5f} > {radio_motor:.5f} y err={err:.5f} ≤ {err_filtro_externo:.5f} → RUÍDO EXTERNO\n')
            continue

        # 3b.2) Si err > err_filtro_externo → MOTOR MUY DAÑADO
        if err > err_max:
            err_max = err
            print(f'[CALIB] Nuevo err_max = {err_max:.5f}')
        denom = max(err_max - args.threshold, 1e-6)
        pct = np.clip((err - args.threshold) / denom, 0, 1) * 100
        print(f'[MOTOR DAÑADO] dist={dist:.5f} > {radio_motor:.5f}, Error={err:.5f}, Daño={pct:6.2f}%\n')
