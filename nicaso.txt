from scipy.signal import welch
import numpy as np

def extract_enhanced_features(signal, sr=16000):
    nperseg = 1024

    # Calcular PSD solo una vez
    freqs, psd = welch(signal, fs=sr, nperseg=nperseg)

    # Bandas predefinidas
    bands = np.array([
        [0, 60],
        [60, 250],
        [250, 2000],
        [2000, 6000],
        [6000, 8000]
    ])
    band_names = ["sub_bajo", "bajo", "medio", "alto", "muy_alto"]

    features = {}

    # Convertimos freqs y psd en arrays numpy para indexaciÃ³n eficiente
    freqs = np.asarray(freqs)
    psd = np.asarray(psd)

    for name, (low, high) in zip(band_names, bands):
        mask = (freqs >= low) & (freqs < high)
        if np.any(mask):
            band_power = np.mean(psd[mask])
        else:
            band_power = 0.0
        features[f"{name}_power"] = band_power

    # ZCR eficiente (evita signo nulo)
    signs = np.sign(signal)
    signs[signs == 0] = 1
    zcr = np.mean(signs[1:] != signs[:-1])

    # RMS
    rms = np.sqrt(np.mean(np.square(signal), dtype=np.float32))

    features["zcr"] = zcr
    features["rms"] = rms

    return features
